use std::str::FromStr;
use crate::ast::Node;
use crate::ast::environment::{Type, Value};
use crate::ast::html::Element;
use crate::ast::expression::Expression;
use crate::ast::function::default_function;
use crate::ast::statement::Statement;

grammar;

pub Daisy: Vec<Node> = {
  <Root*>
};

Root: Node = {
  <c:Statement> => Node::Statement(c),
  Element,
}

// Types / Identifiers

Identifier: String = <s:r"[A-Za-z_][A-Za-z0-9_-]*"> => s.to_string();

Type: Type = {
  "str" => Type::Str,
  "num" => Type::Num,
  "float" => Type::Float,
  "bool" => Type::Bool,
  "element" => Type::Element,
  "func" => Type::Function,
}

Str: String = <s:r#""([^"\\]|\\.)*""#> => s[1..s.len()-1].to_string();
Num: i64 = <s:r"[0-9]+"> => i64::from_str(s).unwrap();
Float: f64 = <s:r"[0-9]+\.[0-9]+"> => f64::from_str(s).unwrap();
Bool: bool = {
  "true" => true,
  "false" => false,
};

// Expressions

Expression: Expression = {
  <l:Expression> "+" <r:Factor> => Expression::Addition(Box::new(l), Box::new(r)),
  <l:Expression> "-" <r:Factor> => Expression::Subtraction(Box::new(l), Box::new(r)),
  Factor,
};

Factor: Expression = {
  <l:Factor> "*" <r:Term> => Expression::Multiplication(Box::new(l), Box::new(r)),
  <l:Factor> "/" <r:Term> => Expression::Division(Box::new(l), Box::new(r)),
  Term,
};

Term: Expression = {
  "(" <Expression> ")",
  <v:Value> => Expression::Value(v),
  <id:Identifier> => Expression::Identifier(id),
  ExpressionCall,
};

Value: Value = {
  <s:Str> => Value::Str(s),
  <n:Num> => Value::Num(n),
  <f:Float> => Value::Float(f),
  <b:Bool> => Value::Bool(b),
  ":" <e:Element> => Value::Element(e.into()),
  Function,
}

ExpressionCall: Expression = {
  <n:Identifier> "(" <args:(<Value> ",")*> <arg:Value?> ")" => {
    let mut args = args;
    if let Some(a) = arg {
      args.push(a);
    }
    Expression::Call(n, args)
  },
}

// Function Expression

FunctionParameters: Vec<Statement> = {
  <args:(<Definition> ",")*> <f:Definition> => {
    let mut params = args;
    params.push(f);
    params
  },
}

Function: Value = {
  "(" <args:FunctionParameters> ")" <return_type:Type> "{" <body:Statement*> "}" => {
    Value::Function(default_function, args, return_type, body)
  },
}

// Statements

Statement: Statement = {
  Definition,
  Assignment,
  Return,
  StatementCall,
}

Definition: Statement = {
  <t:Type> <id:Identifier> "=" <s:Expression> => Statement::Definition(t, id, s),
  <t:Type> <id:Identifier> => Statement::Definition(t, id, Expression::Nil),
}

Assignment: Statement = {
  <id:Identifier> "=" <s:Expression> => Statement::Assignment(id, s),
}

Return: Statement = "return" <s:Expression> => Statement::Return(s.into());

StatementCall: Statement = {
  <id:Identifier> "(" <args:Value*> ")" => Statement::Call(id, args),
}

// html related rules

Insertion: Node = {
  "@" "{" <e:Expression> "}" => Node::Insertion(e),
}

Element: Node = {
  <id:Identifier> <attrs:Attribute*> "{" <body:ElementBody*> "}" => Node::Element(Element::new(id, attrs, body)),
  <id:Identifier> <attrs:Attribute*> ">" <body:ElementBody> => Node::Element(Element::new(id, attrs, vec![body])),
}

Attribute: (String, Vec<Node>) = {
  "#" <id:Identifier> => ("id".to_string(), vec![Node::Text(id)]),
  "." <id:Identifier> => ("class".to_string(), vec![Node::Text(id)]),
  <id:Identifier> "=" <s:Str> => (id, vec![Node::Text(s)]),
}

ElementBody: Node = {
  Insertion,
  Element,
  <s:Str> => Node::Text(s),
}

