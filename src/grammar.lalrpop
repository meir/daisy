use std::str::FromStr;
use crate::ast::Node;
use crate::ast::environment::{Type, Value, Variable};
use crate::ast::html::Element;

grammar;

pub Term: Vec<Node> = {
  <r:Root*> => r
};

Root: Node = {
  <d:Definition> => d,
  <e:Element> => e,
}

Name: String = <s:r"[A-Za-z_][A-Za-z0-9_-]*"> => s.to_string();

Str: String = <s:r#""([^"\\]|\\.)*""#> => s[1..s.len()-1].to_string();
Num: i64 = <s:r"[0-9]+"> => i64::from_str(s).unwrap();
Float: f64 = <s:r"[0-9]+\.[0-9]+"> => f64::from_str(s).unwrap();
Bool: bool = {
  "true" => true,
  "false" => false,
};

Type: Type = {
  "str" => Type::Str,
  "num" => Type::Num,
  "float" => Type::Float,
  "bool" => Type::Bool,
  "element" => Type::Element,
}

Value: Value = {
  <s:Str> => Value::Str(s),
  <n:Num> => Value::Num(n),
  <f:Float> => Value::Float(f),
  <b:Bool> => Value::Bool(b),
  <e:Element> => Value::Element(Box::new(e)),
}

Definition: Node = {
  <t:Type> <n:Name> "=" <v:Value> => Node::Definition(n, Variable::new(t, v)),
}

Insertion: Node = {
  "@" <n:Name> => Node::Insertion(n),
}

Element: Node = {
  <n:Name> <a:Attribute*> "{" <b:Body*> "}" => Node::Element(Element::new(n, a, b)),
  <n:Name> <a:Attribute*> ">" <b:Body> => Node::Element(Element::new(n, a, vec![b])),
}

Attribute: (String, Vec<Node>) = {
  "#" <n:Name> => ("id".to_string(), vec![Node::Text(n)]),
  "." <n:Name> => ("class".to_string(), vec![Node::Text(n)]),
  <n:Name> "=" <s:Str> => (n, vec![Node::Text(s)]),
}

Body: Node = {
  <e:Element> => e,
  <s:Str> => Node::Text(s),
  <i:Insertion> => i,
}
