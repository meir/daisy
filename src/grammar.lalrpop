use std::str::FromStr;
use crate::ast::Node;
use crate::ast::environment::{Type, Value};
use crate::ast::html::Element;
use crate::ast::statement::Statement;

grammar;

pub Term: Vec<Node> = {
  <r:Root*> => r
};

Root: Node = {
  <d:Definition> => d,
  <e:Element> => e,
}

Name: String = <s:r"[A-Za-z_][A-Za-z0-9_-]*"> => s.to_string();

Str: String = <s:r#""([^"\\]|\\.)*""#> => s[1..s.len()-1].to_string();
Num: i64 = <s:r"[0-9]+"> => i64::from_str(s).unwrap();
Float: f64 = <s:r"[0-9]+\.[0-9]+"> => f64::from_str(s).unwrap();
Bool: bool = {
  "true" => true,
  "false" => false,
};

// code related rules

Type: Type = {
  "str" => Type::Str,
  "num" => Type::Num,
  "float" => Type::Float,
  "bool" => Type::Bool,
  "element" => Type::Element,
  "func" => Type::Function,
}

Value: Value = {
  <s:Str> => Value::Str(s),
  <n:Num> => Value::Num(n),
  <f:Float> => Value::Float(f),
  <b:Bool> => Value::Bool(b),
  <e:Element> => Value::Element(Box::new(e)),
  <f:Function> => f,
}

Statement: Statement = {
  <v:Value> => Statement::Value(v),
  <c:Call> => c,
  "return" <s:Statement> => Statement::Return(Box::new(s)),
}

Definition: Node = {
  <t:Type> <n:Name> "=" <s:Statement> => Node::Definition(t, n, s),
  <t:Type> <n:Name> => Node::Definition(t, n, Statement::Nil),
}

FunctionParameters: Vec<Node> = {
  <args:(<Definition> ",")*> <f:Definition> => {
    let mut params = args;
    params.push(f);
    params
  },
}

Function: Value = {
  "(" <args:FunctionParameters> ")" <return_type:Type> "{" <body:Statement*> "}" => {
    Value::Function(|_, _, _|{Value::Nil}, args, return_type, body)
  },
}

Call: Statement = {
  <n:Name> "(" <args:Value*> ")" => Statement::Call(n, args),
}

// html related rules

Insertion: Node = {
  "@" <n:Name> => Node::Insertion(n),
}

Element: Node = {
  <n:Name> <a:Attribute*> "{" <b:ElementBody*> "}" => Node::Element(Element::new(n, a, b)),
  <n:Name> <a:Attribute*> ">" <b:ElementBody> => Node::Element(Element::new(n, a, vec![b])),
}

Attribute: (String, Vec<Node>) = {
  "#" <n:Name> => ("id".to_string(), vec![Node::Text(n)]),
  "." <n:Name> => ("class".to_string(), vec![Node::Text(n)]),
  <n:Name> "=" <s:Str> => (n, vec![Node::Text(s)]),
}

ElementBody: Node = {
  <e:Element> => e,
  <s:Str> => Node::Text(s),
  <i:Insertion> => i,
}

