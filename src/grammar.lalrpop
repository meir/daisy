use std::str::FromStr;
use crate::ast2::environment::{Type, Value};
use crate::ast2::{expression, expression::Expression};
use crate::ast2::{statement, statement::Statement};
use crate::ast2::{node, node::Node, node::Html};
use crate::parser::{parse_string, parse_multiline_string};

grammar;

match {
  r"\/\/[^\n]*" => {}, // single line comment
  r"\/\*([^*]|\*[^\/])*\*\/" => {}, // multi line comment
  r"\s*" => {}, // whitespace
  _
}

pub Daisy: (Option<Expression>, Vec<Statement>) = {
  <meta:Meta?> <body:Statement*> => (meta, body),
};

// keywords

KeyIf = "if";
KeyFor = "for";
KeyMeta = "meta";
KeyCollect = "collect";
KeyBreak = "break";
KeyContinue = "continue";
KeyReturn = "return";

KeyIdentifier: &'input str = <string:r"[A-Za-z_][A-Za-z0-9_-]*"> => string;

KeyValueTrue = "true";
KeyValueFalse = "false";
KeyValueNil = "nil";

KeyTypeString = "str";
KeyTypeNumber = "num";
KeyTypeFloat = "float";
KeyTypeBoolean = "bool";
KeyTypeHtml = "html";
KeyTypeFunction = "func";
KeyTypeMap = "map";
KeyTypeList = "list";

Keyword = {
  KeyIf,
  KeyFor,
  KeyMeta,
  KeyCollect,
  KeyBreak,
  KeyContinue,
  KeyReturn,

  KeyIdentifier,

  KeyValueTrue,
  KeyValueFalse,
  KeyValueNil,

  KeyTypeString,
  KeyTypeNumber,
  KeyTypeFloat,
  KeyTypeBoolean,
  KeyTypeHtml,
  KeyTypeFunction,
  KeyTypeMap,
  KeyTypeList,
};

KeyVariableName = {
  KeyIdentifier,
  KeyMeta,
  KeyTypeHtml,
}

// types

TypeString: Type = KeyTypeString => Type::String;
TypeNumber: Type = KeyTypeNumber => Type::Number;
TypeFloat: Type = KeyTypeFloat => Type::Float;
TypeBoolean: Type = KeyTypeBoolean => Type::Boolean;
TypeHtml: Type = KeyTypeHtml => Type::Html;
TypeFunction: Type = KeyTypeFunction => Type::Function;
TypeMap: Type = KeyTypeMap => Type::Map;
TypeList: Type = KeyTypeList => Type::List;

Type: Type = {
  TypeString,
  TypeNumber,
  TypeFloat,
  TypeBoolean,
  TypeHtml,
  TypeFunction,
  TypeMap,
  TypeList,
};

// Operations

OpEqual = "==";
OpNotEqual = "!=";
OpOr = "||";
OpAnd = "&&";
OpLesser = "<";
OpLesserEqual = "<=";
OpGreater = ">";
OpGreaterEqual = ">=";

OpAdd = "+";
OpSubtract = "-";

OpMultiply = "*";
OpDivide = "/";

// meta

Meta: Expression = {
  (KeyMeta) <map:ExpressionMap> => map,
};

// Shorthands

Definition: (Type, String, Option<Expression>) = {
  <type_:Type> <identifier:KeyVariableName> "=" <expression:Expression> => (type_, identifier.into(), Some(expression)),
  <type_:Type> <identifier:KeyVariableName> => (type_, identifier.into(), None),
};

FunctionParameters: Vec<(Type, String, Option<Expression>)> = {
  <mut parameters:(<Definition> ",")*> <last:Definition?> => {
    if let Some(last) = last {
      parameters.push(last);
    }
    parameters
  },
};

Function: (Vec<(Type, String, Option<Expression>)>, Type, Vec<Statement>) = {
  "(" <parameters:FunctionParameters> ")" <return_type:Type?> "{" <body:Statement*> "}" => {
    if let Some(return_type) = return_type {
      (parameters, return_type, body)
    } else {
      (parameters, Type::Nil, body)
    }
  },
}

// Value

RawValueString: String = {
  <string:r#""(\\.|[^"\n])*""#> => parse_string(string),
  <string:r#"''(\\.|'?[^'])*''"#> => parse_multiline_string(string), 
};
RawValueNumber: i64 = <s:r"[0-9]+"> => i64::from_str(s).unwrap();
RawValueFloat: f64 = <s:r"[0-9]+\.[0-9]+"> => f64::from_str(s).unwrap();
RawValueBoolean: bool = {
  KeyValueTrue => true,
  KeyValueFalse => false,
};

ValueString: Value = <s:RawValueString> => Value::String(s);
ValueNumber: Value = <n:RawValueNumber> => Value::Number(n);
ValueFloat: Value = <f:RawValueFloat> => Value::Float(f);
ValueBoolean: Value = <b:RawValueBoolean> => Value::Boolean(b);
ValueNil: Value = KeyValueNil => Value::Nil;
ValueFunction: Value = <function:Function> => Value::Function(Box::new((function.0.into(), function.1, function.2.into())));
ValueHtml: Value = <html:NodeHtml> => Value::Html(html);

Value: Value = {
  ValueString,
  ValueNumber,
  ValueFloat,
  ValueBoolean,
  ValueNil,
  ValueFunction,
  ValueHtml,
};


// expressions

Expression: Expression = {
  <left:Expression> (OpEqual) <right:ExpressionCalculus> => expression::equal(left.into(), right.into()),
  <left:Expression> (OpNotEqual) <right:ExpressionCalculus> => expression::notequal(left.into(), right.into()),
  <left:Expression> (OpOr) <right:ExpressionCalculus> => expression::or(left.into(), right.into()),
  <left:Expression> (OpAnd) <right:ExpressionCalculus> => expression::and(left.into(), right.into()),
  <left:Expression> (OpLesser) <right:ExpressionCalculus> => expression::lesser(left.into(), right.into()),
  <left:Expression> (OpLesserEqual) <right:ExpressionCalculus> => expression::lesser_equal(left.into(), right.into()),
  <left:Expression> (OpGreater) <right:ExpressionCalculus> => expression::greater(left.into(), right.into()),
  <left:Expression> (OpGreaterEqual) <right:ExpressionCalculus> => expression::greater_equal(left.into(), right.into()),

  ExpressionCall,
  ExpressionScopeEntry,
  ExpressionCalculus,
};

ExpressionCalculus: Expression = {
  <left:ExpressionCalculus> (OpAdd) <right:ExpressionFactor> => expression::add(left, right),
  <left:ExpressionCalculus> (OpSubtract) <right:ExpressionFactor> => expression::subtract(left, right),

  ExpressionFactor,
};

ExpressionFactor: Expression = {
  <left:ExpressionFactor> (OpMultiply) <right:ExpressionTerm> => expression::multiply(left, right),
  <left:ExpressionFactor> (OpDivide) <right:ExpressionTerm> => expression::divide(left, right),

  ExpressionTerm,
};

ExpressionTerm: Expression = {
  "(" <Expression> ")",
  ExpressionValue,
  ExpressionMap,
  ExpressionList,
  ExpressionIdentifier,
  ExpressionScript,
};

ExpressionValue: Expression = <value:Value> => expression::value(value);
ExpressionMap: Expression = "{" <definitions:Definition*> "}" => expression::map(definitions);
ExpressionList: Expression = "[" <mut entries:(<Expression> ",")*> <last:Expression?> "]" => {
  if let Some(last) = last {
    entries.push(last);
  }
  expression::list(entries)
};
ExpressionScopeEntry: Expression = <scope:Expression> "[" <entry:Expression> "]" => expression::object_entry(scope.into(), entry.into());
ExpressionIdentifier: Expression = <location:KeyVariableName> <subsequent:("." <KeyVariableName>)*> => expression::identifier({
  let mut location = vec![location.to_string()];
  location.append(&mut subsequent.iter().map(|s| s.to_string()).collect());
  location
});
ExpressionCall: Expression = <function:Expression> "(" <mut arguments:(<Expression> ",")*> <last_argument:Expression?> ")" => {
  if let Some(last) = last_argument {
    arguments.push(last);
  }
  expression::call(function.into(), arguments)
};
ExpressionScript: Expression = "$"<script:r#"`([^`\\]|\\.)*`"#> => expression::script(script[1..script.len()-1].to_string().into());


// statements

StatementCollect: Statement = (KeyCollect) <expression:Expression> => statement::collect(expression.into());
StatementBreak: Statement = KeyBreak => statement::break_s();
StatementContinue: Statement = KeyContinue => statement::continue_s();
StatementReturn: Statement = {
  (KeyReturn) <expression:Expression> => statement::return_s(Some(expression)),
  (KeyReturn) ";" => statement::return_s(None),
};

StatementIf: Statement = (KeyIf) <condition:Expression> "{" <body:Statement*> "}" => statement::if_s(condition.into(), body);
StatementIter: Statement = {
  (KeyFor) <key:KeyVariableName> "in" <collection:Expression> "{" <body:Statement*> "}" => statement::iter((key.into(), None), collection, body),
  (KeyFor) <key:KeyVariableName> "," <value:KeyVariableName> "in" <collection:Expression> "{" <body:Statement*> "}" => statement::iter((key.into(), Some(value.into())), collection, body),
};
StatementFor: Statement = (KeyFor) <init:StatementDefinition> ";" <condition:Expression> ";" <increment:StatementAssign> "{" <body:Statement*> "}" => statement::for_s(init, condition, increment, body);
StatementDefinition: Statement = <definition:Definition> => statement::define(definition.0, definition.1, definition.2);
StatementAssign: Statement = <identifier:KeyVariableName> "=" <expression:Expression> => statement::assign(identifier.into(), expression.into());
StatementCall: Statement = <function:ExpressionIdentifier> "(" <mut arguments:(<Expression> ",")*> <last_argument:Expression?> ")" => {
  if let Some(last) = last_argument {
    arguments.push(last);
  }
  statement::call(function.into(), arguments)
};

Statement: Statement = {
  StatementReturn,
  StatementCollect,

  StatementIf,
  StatementIter,
  StatementFor,
  StatementDefinition,
  StatementAssign,
  StatementCall,
};

// html

NodeHtml: Node = {
  ":" <node_body:NodeBody> => node_body,
};

NodeBody: Node = {
  <identifier:KeyVariableName> <attributes:NodeAttribute*> "{" <children:Node*> "}" => node::html(Html::new(identifier.into()).with_attributes(attributes).with_children(children)),
  <identifier:KeyVariableName> <attributes:NodeAttribute*> ">" <child:Node> => node::html(Html::new(identifier.into()).with_attributes(attributes).with_children(vec![child])),
  <identifier:KeyVariableName> <attributes:NodeAttribute*> ";" => node::html(Html::new(identifier.into()).with_attributes(attributes)),
};

NodeAttribute: (String, Vec<Node>) = {
  "#" <identifier:Keyword> => ("id".into(), vec![node::text(identifier.into())]),
  "." <identifier:Keyword> => ("class".into(), vec![node::text(identifier.into())]),
  <identifier:Keyword> "=" "(" <value:Expression> ")" => (identifier.into(), vec![node::logic_expression(value)]),
  <identifier:Keyword> "=" <value:ExpressionValue> => (identifier.into(), vec![node::logic_expression(value)]),
  <identifier:Keyword> => (identifier.into(), vec![]),
};

NodeText: Node = <string:RawValueString> => node::text(string);

NodeInsert: Node = "@" "{" <expression:Expression> "}" => node::insertion(expression.into());

Node: Node = {
  <for_loop:StatementFor> => node::logic_statement(for_loop),
  <iter_loop:StatementIter> => node::logic_statement(iter_loop),
  <if_s:StatementIf> => node::logic_statement(if_s),
  
  NodeBody,
  NodeInsert,
  NodeText,
}
